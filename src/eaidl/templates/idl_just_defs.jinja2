{% from "idl/gen_notes.jinja2" import gen_notes %}
{% from "idl/gen_attribute.jinja2" import gen_attribute %}
{% from "idl/gen_class.jinja2" import gen_class_definition_full%}
{# Create module definition, recursively. #}
{% macro gen_module_definition(module, loop) %}
{# {% if module.info.create_definition == True %} #}
{% set module_note = gen_notes(module) %}
{% if module_note | trim %}
{{ module_note }}
{% endif %}
module {{ module.name }} {
{% for submodule in module.packages %}
{{ gen_module_definition(submodule, loop) | trim | indent(4, true) }}
{% endfor %}
{# Phase 1: Forward declarations for recursive structs and unions #}
{% for cls in module.classes %}
{% if cls.is_struct and cls.needs_forward_declaration %}
    struct {{ cls.name }};
{% elif cls.is_union and cls.needs_forward_declaration %}
    union {{ cls.name }};
{% endif %}
{% endfor %}
{# Phase 2: Typedefs and enums (after forward decls, before full definitions) #}
{% for cls in module.classes %}
{% if cls.is_typedef or cls.is_enum %}
{% set class_definition_full = gen_class_definition_full(module, cls) %}
{% if class_definition_full| trim %}
{{ class_definition_full | trim | indent(4, true) }}
{% endif %}
{% endif %}
{% endfor %}
{# Phase 3: Full struct/union definitions #}
{% for cls in module.classes %}
{% if cls.is_struct or cls.is_union %}
{% set class_definition_full = gen_class_definition_full(module, cls) %}
{% if class_definition_full| trim %}
{{ class_definition_full | trim | indent(4, true) }}
{% endif %}
{% endif %}
{% endfor %}
}; /* {{module.name}} */
{# {% endif %} #}
{% endmacro -%}
{% for package in packages %}
module {{package.name}} {
{# Generate definitions for our custom annotations. #}
{% if package.property_types %}
{% if config.ext_ifdef_flag %}
{% if config.ext_ifdef_negate %}
#ifndef {{ config.ext_ifdef_flag }}
{% else %}
#ifdef {{ config.ext_ifdef_flag }}
{% endif %}
{% endif %}
{% for property_type in package.property_types recursive %}
{% set property_note = gen_notes(property_type) %}
{% if property_note %}
{{ property_note | trim | indent(4, true, false) }}
{% endif %}
    @annotation {{property_type.property}} {
{% for type in property_type.property_types recursive %}
        {{type}}
{% endfor %}
    };
{% endfor %}
{% if config.ext_ifdef_flag %}
#endif /* {{ config.ext_ifdef_flag }} */
{% endif %}
{% endif %}
{% for child in package.packages %}
{{ gen_module_definition(child, loop) | trim | indent(4, true) }}
{% endfor %}
{# Phase 1: Forward declarations for recursive structs and unions at top level #}
{% for cls in package.classes %}
{% if cls.is_struct and cls.needs_forward_declaration %}
    struct {{ cls.name }};
{% elif cls.is_union and cls.needs_forward_declaration %}
    union {{ cls.name }};
{% endif %}
{% endfor %}
{# Phase 2: Typedefs and enums (after forward decls, before full definitions) #}
{% for cls in package.classes %}
{% if cls.is_typedef or cls.is_enum %}
{% set class_definition_full = gen_class_definition_full(package, cls) %}
{% if class_definition_full | trim %}
{{ class_definition_full | trim | indent(4, true) }}
{% endif %}
{% endif %}
{% endfor %}
{# Phase 3: Full struct/union definitions #}
{% for cls in package.classes %}
{% if cls.is_struct or cls.is_union %}
{% set class_definition_full = gen_class_definition_full(package, cls) %}
{% if class_definition_full | trim %}
{{ class_definition_full | trim | indent(4, true) }}
{% endif %}
{% endif %}
{% endfor %}
}; /* {{package.name}} */
{% endfor %}
