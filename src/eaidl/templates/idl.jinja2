{% macro gen_attribute(module, cls, attr) -%}
{% if attr.is_collection %}    sequence<{{ "::".join(attr.namespace + [attr.type])}}> {{attr.name}};
{% else %}    {{ "::".join(attr.namespace + [attr.type])}} {{attr.name}};
{% endif -%}
{% endmacro -%}
{% macro get_struct(module, cls) -%}
{% if cls.generalization %}
struct {{ cls.name }}: {{ "::".join(cls.generalization) }} {
{% else %}
struct {{ cls.name }} {
{% endif %}
{% for attr in cls.attributes -%}
{{ gen_attribute(module, cls, attr) }}{% endfor -%}
};
{% endmacro -%}
{% macro gen_class(module, cls) -%}
{% if "idlEnum" in cls.stereotypes %}
enum {{ cls.name }} {
{%- for item in cls.attributes %}
    {{item.name}};{% endfor %}
};
{% elif "idlUnion" in cls.stereotypes %}
union {{ cls.name }} switch (int8)  {
{%- for item in cls.attributes %}
    case {{loop.index}}:
        {{ "::".join(cls.namespace) ~ "::" ~ item.type}} {{item.name}};{% endfor %}
};
{% elif "idlTypedef" in cls.stereotypes %}
    typedef {{cls.parent_type}} {{cls.name}};
{% else %}
{{ get_struct(module, cls) }}
{% endif %}
{% endmacro -%}
{% macro gen_module(module, loop) %}
module {{ module.name }} {
{% for submodule in module.packages %}
{{ gen_module(submodule, loop)|indent(4, False) }}
{% endfor %}
{% for cls in module.classes %}
{{ gen_class(module, cls)|indent(4, False) }}
{% endfor %}
}; /* {{module.name}} */
{%- endmacro -%}



module {{package.name}} {
{% for child in package.packages recursive -%}
{{ gen_module(child, loop)|indent(4, False) }}
{% endfor -%}
}; /* {{package.name}} */