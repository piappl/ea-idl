module ext {

    @annotation exclusiveMaximum {
        any value;
    };

    @annotation exclusiveMinimum {
        any value;
    };

    @annotation maxItems {
        unsigned long value;
    };

    @annotation minItems {
        unsigned long value;
    };

    @annotation interface {
    };
    /**
        Regular expression to match.
    */
    @annotation pattern {
        string value;
    };
}; /* ext */
module core {
    module data {
        module types {
            /**
                ISO timestamp
            */
            @ext::pattern(^((?:(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2}:\d{2}(?:\.\d+)?))(Z|[\+-]\d{2}:\d{2}))$)
            typedef string Time;
            @min(-40)
            @ext::exclusiveMaximum(100)
            typedef float TemperatureMeasurement;
            typedef string Name;
            @ext::pattern([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})
            typedef string Identifier;
        }; /* types */
        enum MeasurementTypeEnum {
            @value(1) MeasurementTypeEnum_TEMPERATURE_MEASUREMENT,
            @value(0) MeasurementTypeEnum_STRING
        };
        enum IdentifierOrNameTypeEnum {
            @value(3) IdentifierOrNameTypeEnum_NAME,
            @value(1) IdentifierOrNameTypeEnum_IDENTIFIER
        };
        union IdentifierOrName;
        struct Store;
    }; /* data */
    module message {
        enum MessageTypeEnum {
            @value(0) MessageTypeEnum_MEASUREMENT,
            @value(1) MessageTypeEnum_EMPTY
        };
        struct MessageHeader;
        typedef string OptionValue;

        /**
            Nationality is 3 letter ISO country code.
        */
        @ext::maxItems(3)
        @ext::minItems(3)
        typedef string Nationality;
        struct Message;
        struct DataMessage;
    }; /* message */
    module data {



        union IdentifierOrName switch (core::data::IdentifierOrNameTypeEnum) {
            case core::data::IdentifierOrNameTypeEnum_IDENTIFIER:
                core::data::types::Identifier identifier;
            case core::data::IdentifierOrNameTypeEnum_NAME:
                core::data::types::Name name;
        };
        struct Store {
            core::data::types::Identifier one;
            sequence<core::data::types::Identifier> sequence;
            @optional
            core::data::types::Identifier optional_one;
            @ext::maxItems(5)
            sequence<core::data::types::Identifier, 5> sequence_upper_bound;
            @ext::minItems(1)
            sequence<core::data::types::Identifier> sequence_lower_bound;
            @ext::minItems(1)
            @ext::maxItems(5)
            sequence<core::data::types::Identifier, 5> sequence_bound;
            @optional
            sequence<core::data::types::Identifier> optional_sequence;
            @ext::maxItems(5)
            @optional
            sequence<core::data::types::Identifier, 5> optional_sequence_upper_bound;
        };
    }; /* data */
    module message {

        /**
            Message header
        */
        struct MessageHeader {
            core::data::types::Time timestamp;
            @default(MessageTypeEnum_MEASUREMENT)
            core::message::MessageTypeEnum message_type;
        };



        @ext::interface
        struct Message {
            core::message::MessageHeader header;
            core::message::Nationality nationality;
        };
        struct DataMessage: core::message::Message {
            @ext::minItems(1)
            @ext::maxItems(5)
            sequence<string, 5> body;
            /**
                This is a sequence
            */
            sequence<long> test_comment_seq;
            /**
                This is optional
            */
            boolean test_comment_optional;
            /**
                This is comment
            */
            double test_comment;
            map<string, core::message::OptionValue> extra;
            core::data::IdentifierOrName identifier;
            core::data::Store store;
        };
    }; /* message */
}; /* core */
