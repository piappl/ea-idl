module ext {
    @annotation exclusiveMaximum {
        any value;
    };
    @annotation exclusiveMinimum {
        any value;
    };
    @annotation maxItems {
        unsigned long value;
    };
    @annotation minItems {
        unsigned long value;
    };
    @annotation interface {
    };
    /**
        Regular expression to match.
    */
    @annotation pattern {
        string value;
    };
}; /* ext */
module core {
    module common {
        module types {
            /**
                ISO timestamp
            */
            @ext::pattern("([0-9]{4}-[0-9]{2}-[0-9]{2})T([0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?)(Z|[\+-][0-9]{2}:[0-9]{2})")
            typedef string Time;
            @min(-40)
            @ext::exclusiveMaximum(100)
            typedef float TemperatureMeasurement;
            typedef string Name;
            @ext::pattern("[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}")
            typedef string Identifier;
        }; /* types */
    }; /* common */
    module data {
        enum MeasurementTypeEnum {
            @value(1) MeasurementTypeEnum_TEMPERATURE_MEASUREMENT,
            @value(0) MeasurementTypeEnum_PRIMITIVE
        };
        /**
            Linked note:
            Not that this enum has values set.
            If not set those will be automatically assigned.
        */
        enum IdentifierOrNameTypeEnum {
            @value(3) IdentifierOrNameTypeEnum_NAME,
            @value(1) IdentifierOrNameTypeEnum_IDENTIFIER
        };
        union IdentifierOrName switch (core::data::IdentifierOrNameTypeEnum) {
            case core::data::IdentifierOrNameTypeEnum_IDENTIFIER:
                core::common::types::Identifier identifier;
            case core::data::IdentifierOrNameTypeEnum_NAME:
                core::common::types::Name name;
        };
        /**
            Linked note:
            Various combinations of optional and multiplicity.
        */
        struct Store {
            core::common::types::Identifier one;
            sequence<core::common::types::Identifier> _sequence;
            @optional
            core::common::types::Identifier optional_one;
            @ext::maxItems(5)
            sequence<core::common::types::Identifier, 5> sequence_upper_bound;
            @ext::minItems(1)
            sequence<core::common::types::Identifier> sequence_lower_bound;
            @ext::minItems(1)
            @ext::maxItems(5)
            sequence<core::common::types::Identifier, 5> sequence_bound;
            @optional
            sequence<core::common::types::Identifier> optional_sequence;
            @ext::maxItems(5)
            @optional
            sequence<core::common::types::Identifier, 5> optional_sequence_upper_bound;
        };
        struct FlexibleName {
            string value;
        };
        enum FlexibleNameValues {
            @value(1) FlexibleNameValues_ONE_VALUE,
            @value(5) FlexibleNameValues_OTHER_VALUE
        };
    }; /* data */
    /**
        Note:
        Random note.

        Note:
        This is formatted note.
        We have bullets:

        * one
        * two

        Enumeration

        1. one
        2. two

        Ther is **bold,** *italic,* underline ***and all of them.***
    */

    module message {
        enum MessageTypeEnum {
            @value(0) MessageTypeEnum_MEASUREMENT,
            @value(1) MessageTypeEnum_EMPTY
        };
        typedef string OptionValue;
        /**
            Nationality is 3 letter ISO country code.

            Linked note:
            Note about nationality.
        */
        typedef string Nationality[3];
        /**
            Message header
        */
        struct MessageHeader {
            core::common::types::Time timestamp;
            @default(core::message::MessageTypeEnum_MEASUREMENT)
            core::message::MessageTypeEnum message_type;
        };
        @ext::pattern("([0-9]{4}-[0-9]{2}-[0-9]{2})T([0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?)(Z|[\+-][0-9]{2}:[0-9]{2})")
        typedef string GUID;
        typedef octet GUIDBytes[16];
        struct Message {
            core::message::MessageHeader header;
            core::message::Nationality nationality;
            core::message::GUIDBytes uuid;
        };
        @ext::interface
        struct DataMessage: core::message::Message {
            @ext::minItems(1)
            @ext::maxItems(5)
            sequence<core::common::types::TemperatureMeasurement, 5> body;
            /**
                This is a sequence
            */
            sequence<long> test_comment_seq;
            /**
                This is optional
            */
            boolean test_comment_optional;
            /**
                This is comment
            */
            double test_comment;
            map<string, core::message::OptionValue> extra;
            core::data::IdentifierOrName identifier;
            core::data::Store store;
            core::data::FlexibleName values;
        };
    }; /* message */
}; /* core */
